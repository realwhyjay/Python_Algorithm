# Do it! 알고리즘 입문 : 선형 탐색

#### Date : 21/05/07

#### Lang : Python

## Question (p. 113 ~ p.119)

원하는 키값의 원소를 찾을때까지 맨 앞부터 스캔하여 순서대로 검색하는 알고리즘을 구현한다.  
입력 값 : 입력받을 원소의 수와 원소의 값들. 검색할 값
출력 값 : 검색할 값이 위치한 인덱스 값 (동일한 값이 있을 경우 처음 검색한 인덱스를 반환)

## 답안 

```python
# while 문으로 작성한 선형 검색 알고리즘
from typing import Any, Sequence

def seq_search(a: Sequence, key: Any) -> int:
    """시퀀스 a에서 key와 값이 같은 원소를 선형 겁색(while문)"""
    i = 0
    while True:
        if i == len(a):
            return -1  # 검색에 실패하여 -1 반환
        if a[i] == key:
            return i  # 검색에 성공하여 현재 검사한 배열의 인덱스를 반환
        i += 1

if __name__ == "__main__":
    num = int(input('원소 수를 입력하세요 : '))  # num 값을 입력받음
    x = [None] * num  # 원소수가 num인 배열을 생성
    for i in range(num):
        x[i] = int(input(f'x[{i}] : '))
    ky = int(input('검색할 값을 입력하세요 : '))  # 검색할 키 ky를 입력받음
    idx = seq_search(x, ky)  # ky와 값이 같은 원소를 x에서 검색

    if idx == -1:
        print('검색값을 갖는 원소가 존재하지 않습니다.')
    else:
        print(f'검색값은 x[{idx}]에 있습니다.')

```

해당 코드의 seq_search함수에서  
 while문이 아닌 for 문을 사용한다면 보다 코드가 간결해진다.  

```python
def seq_search(a: Sequence, key: Any) -> int:
    """시퀀스 a에서 key와 값이 같은 원소를 선형 겁색(for문)"""
    for i in range(len(a)):
        if a[i] == key:
            return i  # 검색 성공 (인덱스를 반환)
    return -1  # 검색 실패 (-1을 반환)

```

위의 선형검색 대로라면 반복을 할 때마다 2가지 종료 조건을 체크한다.  
이 두가지 조건을 체크하는걸 계속해서 반복한다면 그만큼 cost가 들기 때문에 해당 cost를 반으로 줄이기 위해 보초법을 적용한다.  

현재 체크하는 종료 조건은 다음과 같다.    

1. if i == len(a)가 성립하면 스캔 종료 (검색할 값을 찾지 못하고 배열의 맨 끝을 지나갔는지)
2. if a[i] == key 가 성립하면 스캔 종료 (검색할 값과 같은 원소를 찾았는지)

배열에는 입력받은 원소들이 차례로 들어간다. 여기에, 검색하고자 하는 키값을 배열의 맨 끝에 저장한다.  
이 때 저장하는 값을 보초(sentinel)라고 한다.  
보초를 활용한다면 위의 첫번째 조건. 검색할 값을 찾지 못하고 배열의 맨 끝을 지나갔는지를 판단할 필요가 없어진다.   
이처럼 보초는 반복을 종료하는 판단 횟수를 줄이게 되어 검사 cost를 줄인다!  

```python
# 선형 검색 알고리즘(실습3-1)을 보초법으로 수정

from typing import Any, Sequence
import copy


def seq_search(seq: Sequence, key: Any) -> int:
    """시퀀스 seq에서 key와 일치하는 원소를 선형 검색(보초법)"""
    a = copy.deepcopy(seq)  # seq를 복사
    a.append(key)  # 보초 key를 추가

    i = 0
    while True:
        if a[i] == key:
            break  # 검색에 성공하면 while 문을 종료
        i += 1
    return -1 if i == len(a) else i


if __name__ == "__main__":
    num = int(input('원소 수를 입력하세요 : '))  # num값을 입력
    x = [None]*num  # 원소수가 num인 배열을 생성

    for i in range(num):
        x[i] = int(input(f'x[{i}]'))

    ky = int(input('검색할 값을 입력하세요 : '))

    idx = seq_search(x, ky)

    if idx == -1:
        print('검색값 없음')
    else:
        print(f'검색값은 x[{idx}]에 있음')

```


