# 백준 6588 : 골드바흐의 추측

#### Date : 21/01/31

#### Lang : Python

#### Question : [백준 6588](https://www.acmicpc.net/problem/6588)


## 최종 답안

```python
# 시간초과를 해결하기위해, 입력받을 때마다가 아니라 미리 소수를 구해버린다!
# 이전에 소수를 구했던 방식과는 달리 '에라토스테네스의 체'라는 방법을 사용하는게 효율적이라고하여 그 방법을 사용했다.
number = 1000000

# 2부터 시작하여 2를 제외한 2의 배수들 전부 소거하고, 이어서 3의 배수, 4의 배수를 차례대로 전부 소거해주는 방식이다.
# 기본적으로 전부 True로 선언하고, 소수가 아니라면 False로 처리해준다.
# 0,1은 '에라토스테네스의 체' 방식으로 소거가 되지 않기에 처음부터 False로 선언해준다.
# 반복문을 //2 만큼만 도는 이유는 이미 해당 값을 검사가 끝났을 것이기 때문이다.
# 예를들어 8 = 3 + 5임을 알았다면 5+3을 다시 확인하지 않아도 되니까!
goldbach = [False, False]+[True]*(number)
for i in range(2, number//2+1):
    if goldbach[i] == True:
        for j in range(i+i, number+1, i):
            goldbach[j] = False


while True:
    check_num = int(input())
    if check_num == 0:
        break
   
    for i in range(2, check_num//2+1):
      # 두 값의 합이 check_num이 되어야하니, i와 check_num-1 인덱스로 조건을 걸어주었다.
        if goldbach[i] and goldbach[check_num-i]:
            print("{} = {} + {}".format(check_num, i, check_num-i))
            break
        
```

