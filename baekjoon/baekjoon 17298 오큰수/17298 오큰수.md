# 백준 17298 : 오큰수

#### Date : 21/06/14

#### Lang : Python

#### Question : [백준 17298](https://www.acmicpc.net/problem/17298)

## 1차 답안 

```python
import sys
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))
A.append(A[-1])
for i in range(N):
    for j in range(i, N+1):
        #print("count i : {} j : {}".format(i, j))
        if A[i] < A[j]:
            print(A[j], end=' ')
            break
        # elif A[i] >= A[-1] and j == N:
        elif j == N:
            print(-1, end=' ')

```

이렇게 하면 답은 제대로 출력하지만, 시간초과가 나온다.  


##  모범 답안

```python
import sys
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

stack = []
# 오큰수를 못찾은 값은 -1로 출력해주기 위해 -1로 result를 채워준다
result = [-1]*N


stack.append(0)
i = 1

while stack and i < N:
  # 스택에 값이 있고, i가 N보다 작을 경우에
    while stack and A[stack[-1]] < A[i]:
      # 스택에 값이 있고, 스택의 가장 위에 있는 인덱스에 해당하는 값보다 인덱스 i에 해당하는 값이 더 크면
        result[stack[-1]] = A[i] # result 리스트의 해당 인덱스에 값을 저장한다
        stack.pop() # 오큰수를 찾은 인덱스는 pop을 해준다.

    stack.append(i)
    i += 1

for i in result:
    print(i, end=' ')

```

이중 for문을 사용하는 경우 시간 복잡도가 O(N^2)이므로 stack 을 사용하여 O(N)에 가깝게 만들어주었다.    
이걸 어떻게... 생각해내시는지요..?

