# 백준 9095 : 1,2,3 더하기

#### Date : 21/05/07

#### Lang : Python

#### Question : [백준 9095](https://www.acmicpc.net/problem/9095)

## 최종 답안 

```python
T = int(input())

for _ in range(T):
    N = int(input())
    result = 0
    for i in range((N//3)+1):
        for j in range((N//2)+1):
            for k in range(N+1):
                if ((3*i)+(2*j)+k) == N:
                    result += 1
    print(result)

```

처음에는 별 생각 없이 모든 조건을 체크하고, result 값을 하나씩 카운트 해주는식으로 짰다.  
하지만 이 경우에는 모든 조건을 파악하는 것이 아니다.  
예를들어 입력받은 수 4를 만드는 경우의 수 중에는 

1,1,2
1,2,1
2,1,1,

이 있는데 위의 코드로는 1,1,2 만 카운트하고 다른 경우의 수는 체크하지 못한다.  
애초에 문제에 대한 접근을 잘못했음.  
그래서 다른 사람의 코드를 봤는데, DP를 활용한 문제였다.

## 모범 답안

```python
T = int(input())


def sol(n):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    elif n == 3:
        return 4
    else:
        return sol(n-1) + sol(n-2) + sol(n-3)


for in range(T):
    n = int(input())
    print(sol(n))

```

홀리몰리.  
1 -> (1) -> 1개
2 -> (1+1), (2) -> 2개
3 -> (1+1+1), (1+2), (2+1), (3) -> 4개
4 -> (1+1+1+1), (1+1+2), (1+2+1), (1+3), (2+1+1), (2+2), (3+1) -> 7개
5 -> (1+1+1+1+1), (1+1+1+2), (1+1+2+1), (1+1+3), (1+2+1+1), (2+1+1+1), (1+2+2), (2+1+2), (2+2+1), (1+3+1), (3+1+1), (2+3), (3+2) -> 13개

입력받은 수에 따른 경우의 수는 다음과 같다.  
위의 규칙을 보면, 4번째 경우의 수부터 첫번째, 두번째, 세번째 경우의 수의 합이 4번째 경우의 수와 같다.  
이를 통해 (n>3 인 경우) **f(n)=f(n-1)+f(n-2)+f(n-3)** 과 같은 점화식이 나온다.  