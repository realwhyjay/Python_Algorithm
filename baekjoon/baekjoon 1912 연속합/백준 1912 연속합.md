# 백준 1912 : 연속합 

#### Date : 21/09/24

#### Lang : Python

#### Question : [백준 1912](https://www.acmicpc.net/problem/1912)

## 1차 답안 (시간초과)

```python
import sys
input = sys.stdin.readline

n = int(input())
numbers = list(map(int, input().split()))

max = min(numbers)
for i in range(n):
    temp = numbers[i]

    for j in range(i, n):
        if i == j:
            if max < temp:
                max = temp
        else:
            temp += numbers[j]
            if max < temp:
                max = temp

print(max)
```

사실 풀면서부터 조금 쎼하긴 했다.   
무지성으로 풀은거라서.;; ㅎ  
답은 잘 나오지만 시간초과!  
어떻게 시간을 줄일지가 관건이다. 

## 2차 답안 (메모리 초과)

```python

import sys
input = sys.stdin.readline

n = int(input())
numbers = list(map(int, input().split()))

max_num = min(numbers)
result_list = []

for i in range(n):
    result_list.append(numbers[i])
    for j in range(i, n):
        if i == j:
            continue
        else:
            result_list.append(numbers[j]+result_list[-1])

print(max(result_list))
```

매번 값을 비교,대치해주는 것이 아니라 결과값을 담을 list를 만들어서, append 해주는 식으로 바꾸어보았다.  
시간 초과는 나지 않았지만 메모리 초과가 나는 불상사 ㅎ

## 최종 답안 (클론코딩)

```python
import sys
input = sys.stdin.readline

n = int(input())
numbers = list(map(int, input().split()))

# 비교를 위해 입력받은 수의 첫 수를 result에 넣어준다.
result = [numbers[0]]

# result의 i번째 인덱스에 numbers의 1+i 번째 숫자를 합한 값과, 
# numbers의 1+i 번째 숫자를 비교하여 더 큰 숫자를 result에 append 해준다.
for i in range(n-1):
    result.append(max(result[i]+numbers[i+1], numbers[i+1]))

# 최종적으로 result 중에 가장 큰 수를 출력한다
print(max(result))
```

아니 이런 식을 세울 생각을 어떻게 해내는건지 참...  
여태까지의 합에 새로운 숫자를 더한 값과, 새로운 숫자 자체를 비교해서 더 큰 수를 저장하는 방식이다.  
이렇게 하니까 불필요한 for문이 줄어들어 훨씬더 효율적인 계산이 가능해졌다.  
이거는 연습을 좀 해야할듯 ㅠ  
