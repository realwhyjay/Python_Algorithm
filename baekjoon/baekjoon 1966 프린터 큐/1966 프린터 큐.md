# 백준 1966 : 프린터 큐

#### Date : 21/02/12

#### Lang : Python

#### Question : [백준 1966](https://www.acmicpc.net/problem/1966)


## 1차 답안 (실패)

```python
test_case = int(input())

# 사용자에게 입력값 받기
for _ in range(test_case):
    page, where = map(int, input().split())
    priority = list(map(int, input().split()))
    # 가장 높은 우선순위를 파악하기 위한 변수 선언
    priority_max = max(priority)
    count = 0
    # 가장 높은 우선 순위의 값을 저장하기 위한 변수
    check = priority[where]
		
    while True:
        if priority[0] < priority_max:
            priority.append(priority[0])
            priority.pop(0)
        # 여기서 문제가 생긴다 
        # 세번째 예제인 1 1 9 1 1 1 의 경우는 중복되는 수가 나오는데, 이 조건이라면 중복되는 원소들 간의 출력순서를  파악하기가 어렵다. 그래서 실패 ㅎ
        elif priority[0] == priority_max:
            if priority[0] == check:
                count += 1
                print("{}".format(count))
                break
            else:
                priority.pop(0)
                count += 1
                priority_max = max(priority)

```

## 2차 답안 (성공)

```python
test_case = int(input())

for _ in range(test_case):
    page, where = map(int, input().split())
    priority = list(map(int, input().split()))
    priority_max = max(priority)
    count = 0
    # 첫번째 문제를 해결하기 위해 check이라는 리스트를 만들어주고, 정확한 출력 순서를 확인하기 위해 원하는 위치의 원소에만 True 라는 값을 주었다.
    check = ["False" for _ in range(len(priority))]
    check[where] = "True"

    while True:
      # 우선 순위가 가장 크지 않다면 그 원소를 맨 뒤로 보내고 pop 한다.
      # 그 원소의 위치를 파악하기 위해 check list도 똑같이 push와 pop을 해준다.
        if priority[0] < priority_max:
            priority.append(priority[0])
            priority.pop(0)
            check.append(check[0])
            check.pop(0)
      # 만약 제일 앞의 원소가 우선순위가 가장 높은 원소라면, 해당 원소의 check list를 확인해주고 True일 경우에만 break 하도록 한다.
        elif priority[0] == priority_max:
            if check[0] == "True":
                count += 1
                print("{}".format(count))
                break
            else:
                priority.pop(0)
                check.pop(0)
                count += 1
                priority_max = max(priority)

```

## 모범 답안 

```python

test_case = int(input())

for _ in range(test_case):
    n, m = list(map(int, input().split(' ')))
    queue = list(map(int, input().split(' ')))
    # eneumerate()를 사용하여, check를 위한 리스트를 따로 만들어주지 않았다.
    queue = [(i, idx) for idx, i in enumerate(queue)]
    count = 0

    while True:
      # queue의 우선순위가 가장 높은지 파악하고
        if queue[0][0] == max(queue, key=lambda x: x[0])[0]:
            count += 1
          # 해당 원소가 우리가 확인하고자 하는 원소가 맞는지 확인이 될 경우에만 print 후 break
            if queue[0][1] == m:
                print(count)
                break
            else:
                queue.pop(0) 
        else:
            queue.append(queue.pop(0))
```

### eneumerate() 함수

보통 반복문과 함께 사용된다고하는데, 해당 함수를 사용하면 인덱스의 번호와 해당 원소를 tuple 형태로 반환해준다.  
```python
queue = [(i, idx) for idx, i in enumerate(queue)]
```
나동빈님의 경우 이런식으로 인덱스와 원소값의 위치를 바꾼 채로 list에 넣어주었다.  
따라서 원소값(우선순위)를 파악할 때는 queue[0][0]을, 해당 원소의 index를 찾을 때는 queue[0][1]을 사용 한것!  
