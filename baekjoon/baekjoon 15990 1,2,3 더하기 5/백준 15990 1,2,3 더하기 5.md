# 백준 15990 : 1,2,3 더하기 5

#### Date : 21/09/15

#### Lang : Python

#### Question : [백준 15990](https://www.acmicpc.net/problem/15990)

## 최종 답안 

```python
dp = [[0]*4 for _ in range(100001)]

check = 1000000009

dp[0] = [0, 0, 0, 0]
dp[1] = [0, 1, 0, 0]
dp[2] = [0, 0, 1, 0]
dp[3] = [0, 1, 1, 1]

for i in range(4, 100001):
    dp[i][1] = (dp[i-1][2]+dp[i-1][3]) % check
    dp[i][2] = (dp[i-2][1]+dp[i-2][3]) % check
    dp[i][3] = (dp[i-3][1]+dp[i-3][2]) % check

for _ in range(int(input())):
    n = int(input())
    print(sum(dp[n]) % check)

```

점화식을 찾으려고 엄청 애썼는데, 찾지를 못해서 결국 솔루션을 찾아봤다.  
결과적으로는 1,2,3을 사용해 그 수를 만드는데 사용된 개수를 활용한 문제였다.  

dp는 2차 배열로 이루어져 있는데,  
dp[n] 의 [0,0,0,0]은 각각 n을 만들 수 있는 수 중 1,2,3으로 끝나는 수의 개수이다.   
즉 dp [n] [1], dp [n] [2], dp [n] [3] 은 dp[n]을 만들수 있는 수 중 1로 끝나는 수의 개수, 2로끝나는 수의 개수, 3으로 끝나는 수의 개수!

그렇게 구할 수 있는 점화식은 다음과 같다.

```python
DP[i][1] = DP[i - 1][2] + DP[i - 1][3] # 현재 1은 1단계 전의 2 또는 3 에 붙을 수 있다. 
DP[i][2] = DP[i - 2][1] + DP[i - 2][3] # 현재 2은 2단계 전의 1 또는 3 에 붙을 수 있다.
DP[i][3] = DP[i - 3][1] + DP[i - 3][2] # 현재 3은 3단계 전의 1 또는 2 에 붙을 수 있다.

# 1은 1단계 전, 2는 2단계전, 3은 3단계 전의 dp와 비교해주고 있는데, 
# 그 이유는 현재 2로 끝나는 수가 있다면 수가 2만큼 커졌다는 이야기와 같기 때문에, 2단계 전의 수와 비교해주는 것이다!
```

도대체 이런걸 어떻게 뚝딱 찾아내는지 참...