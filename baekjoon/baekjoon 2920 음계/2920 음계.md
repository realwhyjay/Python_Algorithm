# 백준 2920 : 음계

#### Date : 21/02/08

#### Lang : Python

#### Question : [백준 2920](https://www.acmicpc.net/problem/2920)


## 답안

```python
# 음계를 입력 받는다.
scales = list(map(int, input().split()))

# sort한 음계를 ascending에 저장한다
ascending = sorted(scales)

# sort한 음계를 descending한 뒤, reverse 해준다.
descending = sorted(scales)
descending.reverse()

# 세개의 리스트를 비교하여 적합한 내용을 print 해준다.
if scales == ascending:
    print("ascending")
elif scales == descending:
    print("descending")
else:
    print("mixed")

```



## 리스트 복사하기
맨 처음에는 scales에 리스트를 입력받고 ascending과 descending 변수에 리스트를 복사한 뒤 sort()를 하려고 했었다.  
```python
scales = list(map(int, input().split()))

ascending = scales
ascending.sort()

print(scales, ascending)
```
이 상황에서 [8,5,6,4,7,1,2,3]을 입력해본다고 해보자.  
내 생각에는 당연히 [8,5,6,4,7,1,2,3] [1,2,3,4,5,6,7,8] 이 출력될거라고 생각했는데 아니었다.  
[1,2,3,4,5,6,7,8] 만 두번 출력되는 어이없는 상황 ;;  
  
알고보니 리스트를 복사할 때는 일반적인 변수를 복사하듯이 복사가 불가능했다.  
ascending에 scales를 대입한다고 하더라도 리스트의 내용이 복사되는 것이 아니라, 입력받은 리스트를 참조하는 변수가 두개로 늘어나게 되는 것 뿐이다.   
따라서 ascending과 scales는 동일한 객체를 가리키고 있는 것이고, 그렇기에 두 변수 모두 sort된 리스트의 값을 가지게 되는 것이다.  

만일 리스트를 복사하려고 한다면 [:]를 활용하면 된다.  

```python
scales = list(map(int, input().split()))
ascending = scales[:]
```

## sort(), sorted(), reverse()
또 다른 시도로는 ascending과 descending 변수에 바로바로 sort(), reverse()를 해서 리스트를 저장해주려고 하였다.  
```python
scales = list(map(int, input().split()))

ascending = scales.sort()
descending = ascending.reverse()
```

기본적으로 sort()와 reverse()는 리턴값을 가지지 않는다.  
해당 리스트를 정렬해주지만 리턴을 해주지 않아서 ascending과 descending을 print를 해주면 ascending은 None 값이 나올테고, descending은 프린트는 커녕 프로그램을 죽여버린다.  

생각만으로는 scales 가 정렬된 채 ascending에 복사될 것이라고 생각했는데, 리턴값이 없으니 당연히 되질 않는다.  
하지만 sorted()를 사용해주면 정렬한 리스트를 복사하여 리턴해줄 수 있다.  
따라서 다음과 같은 방식으로 정렬을 시켜 해결해주었다.
```python
ascending = sorted(scales)

descending = sorted(scales)
descending.reverse()

```

## 모범답안
```python
a = list(map(int, input().split(' ')))

ascending = True
descending = True

for i in range(1, 8):
    if a[i] > a[i - 1]:
        descending = False
    elif a[i] < a[i - 1]:
        ascending = False

if ascending:
    print('ascending')
elif descending:
    print('descending')
else:
    print('mixed')
```

왜 나는 이렇게 풀 생각을 못했지;;  
나동빈님은 각 리스트의 요소들을 비교하면서 descending, ascending 여부를 체크해주었다.  
내가 푼 방식과 처리 시간은 똑같아서 결과적으로는 다행이라거 생각했다.. ㅎ  