# 백준 1668 : 트로피 진열

#### Date : 21/03/06

#### Lang : Python

#### Question : [백준 1668](https://www.acmicpc.net/problem/1668)

## 1차 답안 (실패)

```python
num = int(input())
trophy = []

for _ in range(num):
    trophy.append(int(input()))

for i in range(len(trophy)):
    if i == 0:
        result = 1
    else:
        if trophy[i] > trophy[i-1]:
            result += 1
        continue

print(result)

trophy.reverse()

for i in range(len(trophy)):
    if i == 0:
        result = 1
    else:
        if trophy[i] > trophy[i-1]:
            result += 1

print(result)

```

너무 단순하게 생각해서 앞 트로피와의 높이를 비교해주면 된다고 생각했다.  
이를 해결하기위해 가장 큰 높이와 비교하도록 수정해 주었다.   

## 2차 답안 

```python
num = int(input())
trophy = []

for _ in range(num):
    trophy.append(int(input()))

# 현재 트로피의 높이를 앞에 놓여진 트로피 중 최대 높이와 비교했을 때, 수를 하나씩 늘려주도록 하였다.
for i in range(len(trophy)):
    if i == 0:
        result = 1
        max = trophy[i]
    else:
        if trophy[i] > max:
            result += 1
            max = trophy[i]

print(result)

# 반대쪽에서 보는건 리스트를 reverse 해준뒤 똑같은 탐색을 반복하도록 하였다. 
trophy.reverse()

for i in range(len(trophy)):
    if i == 0:
        result = 1
        max = trophy[i]
    else:
        if trophy[i] > max:
            result += 1
            max = trophy[i]

print(result)

```



## 최종 답안

```python
def trophy_count(trophys):
    result = 0
    for i in range(len(trophys)):
        if i == 0:
            result = 1
            max = trophys[i]
        else:
            if trophys[i] > max:
                result += 1
                max = trophys[i]
    return result


num = int(input())
trophy = []


for _ in range(num):
    trophy.append(int(input()))


print(trophy_count(trophy))

trophy.reverse()

print(trophy_count(trophy))

```

2차 답안과 똑같은 코드이지만, 두 번 반복하는 탐색을 함수로 만들어주어 가독성을 높였다. 