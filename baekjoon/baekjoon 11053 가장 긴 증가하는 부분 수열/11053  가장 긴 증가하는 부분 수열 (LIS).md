# 백준 11053 : 가장 긴 증가하는 부분 수열 (LIS)

#### Date : 21/09/21

#### Lang : Python

#### Question : [백준 11053](https://www.acmicpc.net/problem/11053)

## 1차 답안 

```python
n = int(input())
a = list(map(int, input().split()))

min = 0
count = 0

for i in a:
    if i >= min:
        min = i
        count += 1

print(count)

```

처음엔 아무 생각 없이 짜주었는데, 문제를 잘못이해해서 풀었다.   
수열에서, 수가 이전보다 증가할때마다 길이를 늘려주어야하는데,   
나는 무조건 모든 수열에서 수가 차례로 증가하는 경우에만 길이를 늘려주어야하는 것으로 착각했다.

## 최종 답안

```python
n = int(input())
a = list(map(int, input().split()))

dp = [1]*n

for i in range(n):
    for j in range(i):
        if a[i] > a[j]:
            dp[i] = max(dp[i], dp[j]+1)

print(max(dp))

```

1. dp[i]의 값을 1로 초기화
2. 현재 위치(i)보다 이전에 있는 원소(j)가 작은지 확인한다. (크거나 같으면 가장 긴 증가하는 부분 수열이 될 수 없음)
3. 작다면, 현재 위치의 이전 숫자 중, dp 최댓값을 구하고 그 길이에 1을 더해주면 된다.
   그냥 dp[i]+1을 해주지 않는 이유는 for문 안에서 j가 바뀔때마다 dp[i]를 갱신해주는데, 
   만약 그냥 dp[i]+1 을 해주게 된다면 도중에 증가하지 않고 감소한 수를 만났을때, 그 감소한 수의 dp[i]는 무조건 1이기 때문에, 이전에 dp[i]와 상관없이 현재 dp[i]가 무조건 2로 갱신되어버린다.
4. 최종적으로는 dp배열의 원소 중 가장 큰 원소를 출력한다.