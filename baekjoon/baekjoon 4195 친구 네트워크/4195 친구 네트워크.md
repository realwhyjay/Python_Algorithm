# 백준 4195 : 친구 네트워크

#### Date : 21/02/20

#### Lang : Python

#### Question : [백준 4195](https://www.acmicpc.net/problem/4195)

## 클론 코딩 답안

```python
'''
x로 들어온 원소의 root 노드를 반환하는 함수
find() 함수의 목적은 x의 최종 부모 노드를 찾는 것이기 때문에, 
만약 노트 x 가 최종적인 부모 노드가 아니라면 
그 부모노드(parent(x))의 부모(find(parent[x]))를 찾는 재귀함수이다.
'''


def find(x):
    if x == parent[x]:
        return x
    else:
        p = find(parent[x])
        parent[x] = p
        return parent[x]


'''
union 함수는 x와 y의 root 노드를 찾고, 
그 둘의 root 노드가 같지 않다면 (x와 y가 아무런 관계가 없다면)
y의 root 노드를 x의 root 노드로 만들어준다.
'''


def union(x, y):
    # x와 y의 root 노드를 찾는다
    x = find(x)
    y = find(y)
    # 그 둘이 같지 않다면 (x,y가 연결되어있지 않다면)
    if x != y:
        # y의 root 노드를 x의 root 노드의 자식이 되도록 만든다
        parent[y] = x
        # number는 해당 노드와 연결되어있는 관계의 수를 의미하니, 기존 y에 연결되어있던 수를 더해준다.
        number[x] += number[y]


test_case = int(input())

for _ in range(test_case):
    f = int(input())
    # 빈 딕셔너리 선언
    parent = dict()
    number = dict()

    for _ in range(f):
        x, y = input().split()
        # 입력받은 x와 y가 부모노드에 없다면 추가를 해준다.
        # 관계의 수를 의미하는 number 또한 1로 선언해준다.
        if x not in parent:
            parent[x] = x
            number[x] = 1
        if y not in parent:
            parent[y] = y
            number[y] = 1

        # 입력 받은 x,y의 관계를 확인해보고, 연결이 되어있지 않다면 둘을 이어준다.
        union(x, y)

        # number 딕셔너리에 있는 find(x)라는 키값의 value를 프린트한다.
        # 즉, 결국 x의 최종 root가 가지고 있는 관계의 수를 출력해주는 것.
        print(number[find(x)])

```



도저히 혼자서는 풀 수가 없어 클론 코딩을 진행했다.  
스스로 시도했을때는 set을 사용하려 했는데... 잘 안됨 ㅎㅎ  
여러번 다시 풀어봐야 할 것 같다.

### 참고 설명들

https://assaeunji.github.io/python/2020-05-05-bj4195/  
https://ko.wikipedia.org/wiki/서로소_집합_자료_구조

