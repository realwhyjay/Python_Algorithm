# 백준 2839 : 설탕 배달

#### Date : 21/05/06

#### Lang : Python

#### Question : [백준 2839](https://www.acmicpc.net/problem/2839)

## 최종 답안 

```python
kg = int(input())
max = (kg//3)+1
bag = max

for i in range((kg//5)+1):
    for j in range((kg//3)+1):
        if ((5*i)+(3*j)) == kg:
            bag = i+j if (i+j) < bag else bag

print(bag if bag != (kg//3)+1 else -1)

```

이중 포문을 사용해주었다.  
풀어서 맞긴 맞았는데...  
이중 포문을 사용하는 특성상, 모든 경우의 수를 다 체크해 주어야하니 효율이 떨어진다고 생각했다.  
그래서 더 나은 방법을 찾아보았다.

## 모범 답안

```python
N = int(input())

result = 0

while True:
    if N % 5 == 0:
        result += (N//5)
        print(result)
        break

    N -= 3
    result += 1

    if N < 3:
        print(-1)
        break
```

홀리몰리.  
모든 경우의 수를 전부 체크한 내 답안과는 달리.  
결과적으로 result의 개수만큼만 확인하는 코드를 발견했다.  
나는 왜 저렇게 생각 못했을까.. ㅎ 